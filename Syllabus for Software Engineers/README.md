# üß† Building LLM-Powered Applications with Open-Source Tools

## üìò Course Overview

This self-paced MSc-level course teaches you how to build real-world applications using Large Language Models (LLMs) ‚Äî entirely with **open-source tools**. You‚Äôll gain hands-on experience with modern frameworks, pipelines, and deployment strategies, without depending on commercial APIs.

As generative AI transforms industries, the ability to design, deploy, and evaluate LLM-based solutions is a critical skill for software engineers. This course focuses on **practical workflows**, enabling you to create interactive, LLM-powered applications that are portable, customizable, and production-ready.

## üë®‚Äçüíª Who This Course is For

This course is designed for **experienced software engineers and technical professionals** who are:

- Comfortable with **Python**, REST APIs, and backend/frontend basics
- New to AI/LLMs but curious to learn quickly
- Looking for **practical, code-driven workflows**, not academic theory

You do **not** need prior ML or data science experience. However, this course is **not suitable** for:
- Learners without any programming background
- Those seeking to **train large models from scratch**
- Those expecting coverage of deep mathematical theory

## üéØ What You‚Äôll Learn

By the end of the course, you‚Äôll be able to:

- Run and use open-weight LLMs (e.g., LLaMA 2, Mistral, Phi-2)
- Apply prompt engineering techniques (zero-shot, few-shot, CoT)
- Generate and use embeddings for vector search
- Build Retrieval-Augmented Generation (RAG) pipelines
- Develop and deploy LLM apps with APIs and UIs
- Implement guardrails and evaluate model outputs
- (Optional) Explore quantization, fine-tuning, and agentic orchestration

## üß© Course Structure

The course consists of **8 hands-on modules** plus a **Capstone Project**, totaling **60‚Äì80 hours** of effort. Each module includes:

- A 6‚Äì12 hour time budget
- Required reading and lab-based resources
- One assignment to apply key skills
- Optional enrichment for advanced learners

It‚Äôs **asynchronous and self-paced**, ideal for solo learners or teams of 2‚Äì3.

## üõ† Tools & Technologies Used

You‚Äôll work with a rich ecosystem of **open-source tools**, including:

- **Hugging Face Transformers** (model loading, inference)
- **LangChain** and **LlamaIndex** (pipeline orchestration)
- **Vector databases**: Chroma, Qdrant, Weaviate
- **App frameworks**: FastAPI, Streamlit, Gradio
- **Containers**: Docker, Hugging Face Spaces, Colab
- (Optional) vLLM, LoRA, Guardrails AI, Rebuff

## üîç What to Expect

This is a **hands-on, application-focused** course. You will:

- Write Python code, build pipelines, and run real models
- Use **open-weight models** (no reliance on GPT APIs)
- Focus on **real use cases**, not research papers
- Learn modern LLM patterns like RAG, semantic search, and guardrails

## üö´ What Not to Expect

To help set the right expectations, this course:

- Does **not cover deep math** or ML model training
- Does **not require GPU clusters** or enterprise-scale infra
- Does **not teach** general AI/ML theory or foundational algorithms
- Is **not for beginners in coding or Python**

## ‚è± Time Commitment & Pacing

- Total: **60‚Äì80 hours**
- Recommended pace: **6‚Äì8 hours/week** for 6‚Äì10 weeks
- Modular structure: Flexible order, milestone assignments
- Optional enrichment adds depth but isn‚Äôt required

## üéì Capstone Project

The course culminates in a **capstone design and prototype**:

- Build an **LLM-powered app** in a real domain (e.g. tutoring, productivity, customer support)
- Combine prompting, RAG, UI/API, and evaluation
- Include at least one evaluation mechanism and one guardrail
- This becomes a **portfolio-worthy deliverable**

## üß™ Optional Primers

This course is designed for experienced software engineers, but learners without a strong foundation in Python or recent exposure to core mathematical concepts may benefit from two optional preparatory primers. These primers are **not included** in the core 60‚Äì80 hour learning time but are recommended for those who need a refresh before diving into the main modules.

### üìê Math for AI Primer (Module 0 ‚Äì Optional, 10 hours)

This optional module is intended for learners who feel unfamiliar with concepts such as vectors, matrices, dot products, probability distributions, or logarithms. It offers an intuitive and visual review of math fundamentals as they appear in embeddings, vector search, and model evaluation throughout the course.

**Key outcomes:**
- Understand how linear algebra and probability underpin LLM workflows
- Gain confidence with concepts like cosine similarity and matrix multiplication
- Practice math tasks like computing similarities or evaluating simple probabilities

Resources include video series from 3Blue1Brown, Khan Academy exercises, and short applied explainers. The module culminates in a short write-up or notebook with basic math calculations and AI-relevant explanations.

### üêç Python Primer for Engineers (Optional, ~6‚Äì10 hours)

Learners without working knowledge of modern Python (especially those from compiled-language backgrounds like C#, Java, or C++) are encouraged to complete this standalone primer before beginning Module 1. The primer emphasizes practical fluency in Python syntax, functions, object handling, and package management.

**Key outcomes:**
- Write idiomatic Python using Jupyter, Colab, or local scripts
- Work with lists, dicts, sets, and common control structures
- Use key libraries relevant to this course (e.g., `transformers`, `requests`, `numpy`)
- Handle errors, structure projects, and install packages confidently

This primer includes curated lessons, hands-on coding tasks, and a small diagnostic to ensure readiness for LLM work in Python. It is especially useful for engineers transitioning from enterprise or strongly typed environments.


## üöÄ Getting Started

**Prerequisites**:
- Working knowledge of Python and Git
- Ability to run Jupyter/Colab notebooks
- Basic familiarity with HTTP APIs and JSON

**Recommended Setup**:
- VS Code or Jupyter Notebook
- Google Colab or local Python environment
- Docker (for deployment modules)

## üß™ Methodology

This course was developed using a structured, multi-phase curriculum design approach, guided by best practices in instructional design and real-world tooling. The design process relied heavily on the capabilities of GPT-4o in DeepResearch mode to generate, refine, and validate syllabus content.

### Curriculum Development Phases

1. **Phase 1 ‚Äì Target Definition**: Clarified the course's scope, target audience, and exclusion criteria to ensure a focused learning experience.
2. **Phase 2 ‚Äì Learning Outcomes Design**: Defined clear, measurable learning outcomes and the practical capabilities learners should acquire.
3. **Phase 3 ‚Äì Module-by-Module Development**: Built detailed Trello-style module cards including learning goals, curated resources, hands-on assignments, optional enrichment, and collaborative sync activities.
4. **Phase 4 ‚Äì Quality Review and Thematic Coherence**: Conducted a cross-module review to ensure continuity, progression, and balanced tool coverage.
5. **Phase 5 ‚Äì Delivery Enablement**: Finalized course assets (PDF syllabus, README, assistant agent, and Trello board) to support self-paced learner execution.

### Tools Used

The syllabus was created with the support of:

- **GPT-4o (DeepResearch mode)** ‚Äî for content generation, sourcing, and curriculum structuring.
- **Open-source resources** ‚Äî no paywalled or proprietary tools were recommended to maintain accessibility.
- **Human review and curation** ‚Äî every module was iteratively refined and validated for accuracy, clarity, and technical alignment.

This methodology ensured the course remains rigorous, hands-on, and tightly aligned with the workflows of modern AI engineers using open-source tooling.

## üìÑ License

This course is licensed under the **Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)** license.

You are free to **share**, **download**, and **use this course content for personal, non-commercial purposes**, provided that you:

- **Credit the original author**
- **Do not distribute modified versions of the content**
- **Do not use the materials in corporate, institutional, or commercial training programs** without prior written permission

üî∏ *Personal learning note:* You may privately annotate or adapt the material for your own learning, as long as you do not distribute your modified version.

[Read the full license terms here](https://creativecommons.org/licenses/by-nc-nd/4.0/)

---

Ready to start building? Clone this repo, explore the syllabus, and dive into Module 1!
